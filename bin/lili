#!/usr/bin/env ruby

require 'rubygems'
require 'find'
require 'optparse'
require 'dotsmack'
require 'yaml'
require 'lili'
require 'json'

def main
  ignores = DEFAULT_IGNORES

  configuration_flags = {}

  option = OptionParser.new do |option|
    option.banner = 'Usage: lili [options] [<files>]'

    option.on('-i', '--ignore pattern', 'Ignore file pattern (fnmatch)') do |pattern|
      ignores << pattern
    end

    option.on('-h', '--help', 'Print usage info') do
      puts option
      exit
    end

    option.on('-v', '--version', 'Print version info') do
      puts "lili #{LiLi::VERSION}"
      exit
    end
  end

  option.parse!

  filenames =
    if ARGV == []
      ['.']
    else
      ARGV
    end

  dotsmack = Dotsmack::Smacker.new(
    dotignore = '.lili-ignore',
    additional_ignores = ignores,
    dotconfig = '.lili-rc.yml'
  )

  puts <<-eos
{
  "statVersion": "0.4.0",
  "process": {
    "name": "Line Ending Linter",
    "version": "0.3.0",
    "description": "lili searches your source code files for strange line endings that may cause issues with software interoperability",
    "maintainer": "Andrew Pennebaker",
    "email": "andrew.pennebaker@gmail.com",
    "website": "https://github.com/mcandre/lili",
    "repeatability": "Associative"
  },
  "findings": [
  eos

  finding_count = 0

  dotsmack.enumerate(filenames).each do |filename, config, i|
    config =
      if config.nil?
        DEFAULT_CONFIGURATION.merge(configuration_flags)
      else
        DEFAULT_CONFIGURATION.merge(YAML.load(config)).merge(configuration_flags)
      end

    check(filename, config) { |finding|
      puts "," if finding_count > 0
      print JSON.pretty_generate(finding).lines.map { |line| '    ' + line }.join
      finding_count += 1
    }
  end

  puts <<-eos

  ]
}
  eos


end

begin
  main
# User may quit lili before completion.
rescue Interrupt
  nil
# lili may be piped to another program (e.g. `less`),
# which is quit before lili completes.
rescue Errno::EPIPE, Errno::EMFILE
  nil
end
